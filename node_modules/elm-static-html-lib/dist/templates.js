"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
// literally the only reason why this has to be an npm package
function generateNativeModuleString(projectName) {
    var fixedProjectName = projectName.replace(/-/g, "_");
    var nativeString = "\nfunction forceThunks(vNode) {\n    if (typeof vNode !== \"undefined\" && vNode.ctor === \"_Tuple2\" && !vNode.node) {\n        vNode._1 = forceThunks(vNode._1);\n    }\n    if (typeof vNode !== 'undefined' && vNode.type === 'thunk' && !vNode.node) {\n        vNode.node = vNode.thunk.apply(vNode.thunk, vNode.args);\n    }\n    if (typeof vNode !== 'undefined' && typeof vNode.children !== 'undefined') {\n        vNode.children = vNode.children.map(forceThunks);\n    }\n    return vNode;\n}\n\nvar _" + fixedProjectName + "$Native_Jsonify = {\n    stringify: function(thing) { return forceThunks(thing) }\n};";
    return nativeString;
}
exports.generateNativeModuleString = generateNativeModuleString;
function importLine(fullFunctionName) {
    return "import " + fullFunctionName.substr(0, fullFunctionName.lastIndexOf("."));
}
function functionName(functionLine) {
    return functionLine.substr(functionLine.lastIndexOf("."));
}
function initBodyWithDecoder(viewHash, viewFunction, decoderName) {
    return "\ninit : Json.Value -> ((), Cmd msg)\ninit values =\n    case Json.decodeValue " + decoderName + " values of\n        Err err -> ((), htmlOut" + viewHash + " (\"ERROR:\" ++ err))\n        Ok model ->\n            ((), htmlOut" + viewHash + " <| decode <| " + viewFunction + " model)\n";
}
function initBodyWithoutDecoder(viewHash, viewFunction) {
    return "\ninit : Json.Value -> ((), Cmd msg)\ninit _ =\n    ((), htmlOut" + viewHash + " <| decode <| " + viewFunction + ")\n";
}
// this is our render's file contents
// basically just boilerplate
function generateRendererFile(viewHash, viewFunction, decoderName, newLines, indent) {
    var imports = importLine(viewFunction) + "\n";
    if (decoderName) {
        imports += importLine(decoderName);
    }
    var initBody;
    if (decoderName) {
        initBody = initBodyWithDecoder(viewHash, viewFunction, decoderName);
    }
    else {
        initBody = initBodyWithoutDecoder(viewHash, viewFunction);
    }
    var newLinesStr;
    if (newLines === undefined || newLines === true) {
        newLinesStr = "True";
    }
    else {
        newLinesStr = "False";
    }
    var indentStr = indent !== undefined ? indent : 4;
    var optionsSet = "options = { defaultFormatOptions | newLines = " + newLinesStr + ", indent = " + indentStr + " }";
    var rendererFileContents = "\nport module PrivateMain" + viewHash + " exposing (..)\n\nimport Platform\nimport Html exposing (Html)\nimport ElmHtml.InternalTypes exposing (decodeElmHtml)\nimport ElmHtml.ToString exposing (nodeToStringWithOptions, defaultFormatOptions)\nimport Json.Decode as Json\nimport Native.Jsonify\n\n" + imports + "\n\n\nasJsonView : Html msg -> Json.Value\nasJsonView = Native.Jsonify.stringify\n\n" + optionsSet + "\n\ndecode : Html msg -> String\ndecode view =\n    case Json.decodeValue decodeElmHtml (asJsonView view) of\n        Err str -> \"ERROR:\" ++ str\n        Ok str -> nodeToStringWithOptions options str\n\n" + initBody + "\n\nmain = Platform.programWithFlags\n    { init = init\n    , update = (\\_ b -> (b, Cmd.none))\n    , subscriptions = (\\_ -> Sub.none)\n    }\n\nport htmlOut" + viewHash + " : String -> Cmd msg\n";
    return rendererFileContents;
}
exports.generateRendererFile = generateRendererFile;
